# Driver for Instrumentation Library

### Function Analyser

The function analyser evaluates function output channels (paths) for a specified system program to determine how they can be modified in order to improve a given objective (e.g. code size for binaries generated by a compiler system program).

The ```scripts``` folder contains a sample bash script ```run_evaluation.sh``` which shows how it can be configured and executed. The following is a description of program arguments:

```
  -h, --help            show this help message and exit
  --run_id ID           ID used to identify this evaluation execution.
  --working_dir DIR     Directory for generated data.
  --config JSON         Json file with evaluation configuration.
  --heuristicDB URL     SQL DB indicating previously collected information about heuristic statistics.
  --function_cache FILE
                        File path to target function cache. If file does not exist, a cache will be
                        create after colleting functions.
  --baseline_cache FILE
                        File path to baseline statistics cache. If file does not exist, a cache will
                        be create after measuring baselines.
  --bmark_filter [SUITE#B1,B2,B3... ...]
                        List of manually specified benchmarks using key value lists
                        <suite#name1,name2,name3>, e.g. POLYBENCH#correlation,lu
  --target_functions FILE
                        A specific list of target function names to be instrumented.
  --target_filter FILE  A specific list with block and allow rules for evaluation targets.
  --fn_chunk_size SIZE  Number of functions to be evaluated by this evaluation run. (considered only
                        if --target_functions is used)
  --fn_chunk_offset OFFSET
                        Start offset for functions to be evaluated. (considered only if
                        --target_functions is used)
  --instr_scope VALUE   Scope of instrumentation to be used [FUNCTION, MODULE, ALL].
  --instr_chunk VALUE   Chunk size of for instrumentation scope.
  --keep_probes         Keep probe code and probe folders around. ATTENTION: disk space intensive for
                        long runs.
  --cpus VALUE          Number of available CPUs for this run.
  --worker_mul VALUE    Number of workers is the configured cpus times this multiplier.
  --exact_cpu_map       If this flag is active, workers and main thread are mapped exactly to the
                        number of cpus. worker_mul flag is ignored and cpus has to be larger 1.
  --probe_mem_limit VALUE
                        Memory limit in MB granted to each probe compilation and probe run.
  --loglevel LEVEL      Configure log level.
  --dry_run             If this flag is active, the amount of work left to do for the given
                        configuration is evaluated and no analysis is executed.
  --skip_immutables     If this flag is active, immutable function parameter paths are skipped after
                        Null Prior.
  --independent_test_cases
                        If this flag is active, test cases are considered as independent applications.
  --no_instr            Deactivate instrumentation for debugging purposes.
  --record_exec_log     If active, all probed values are stored in the database.
  -v, --verbose         Activate verbose program output.
```

### Benchmark Profiler

The benchmark profiler traces for a given set of benchmarks and already instrumented system program, which functions are executed by which benchmark.

The ```scripts``` folder contains a sample bash script ```run_profiling.sh``` which shows how it can be configured and executed. The following is a description of program arguments:

```
  -h, --help         show this help message and exit
  --run_id ID        ID used to identify this profiler execution.
  --working_dir DIR  Directory for generated data.
  --config JSON      Json file with environment and instrumented compiler configuration.
  --loglevel LEVEL   Configure log level.
  -v, --verbose      Activate verbose program output.
```

### Generate Extension

This script is useful when testing extension code generation for specific instrumented functions. It does not require an instrumented system program as it only generates the extension for a given module, function and path from the system program and does not execute it.

The following is a description of program arguments:

```
  -h, --help            show this help message and exit
  --mod NAME            Specify a module name.
  --fn NAME             Specify a function name.
  --path NAME           Specify a path name.
  --working_dir DIR     Directory for generated data.
  --config_dir DIR      Directory holding function configuration data generated by the instrumentation pass.
  --function_cache FILE
                        File path to function cache. If file does not exist, a cache will be create
                        after colleting functions.
```

